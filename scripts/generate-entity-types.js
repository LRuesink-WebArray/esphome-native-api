#!/usr/bin/env node

/**
 * Generate entity types from proto files
 * This script parses api.proto and generates TypeScript type definitions
 * for all entity types, making the library automatically stay in sync with ESPHome
 */

const fs = require('fs');
const path = require('path');

const PROTO_FILE = path.join(__dirname, '../proto/api.proto');
const OUTPUT_FILE = path.join(__dirname, '../src/types/generated-entity-types.ts');

// Parse proto file and extract entity types
function parseProtoFile(content) {
  const entities = [];
  
  // Match all ListEntities*Response messages
  const entityRegex = /message\s+ListEntities(\w+)Response\s*\{/g;
  let match;
  
  while ((match = entityRegex.exec(content)) !== null) {
    const entityName = match[1];
    
    // Skip special cases that aren't actual entities
    if (entityName === 'Done' || entityName === 'Services') {
      continue;
    }
    
    entities.push(entityName);
  }
  
  return entities;
}

// Convert entity name to snake_case
function toSnakeCase(str) {
  // Handle special cases
  const specialCases = {
    'BinarySensor': 'binary_sensor',
    'TextSensor': 'text_sensor',
    'AlarmControlPanel': 'alarm_control_panel',
    'MediaPlayer': 'media_player',
    'DateTime': 'datetime',
  };
  
  if (specialCases[str]) {
    return specialCases[str];
  }
  
  // Convert PascalCase to snake_case
  return str.replace(/([A-Z])/g, (match, letter, index) => {
    return index > 0 ? '_' + letter.toLowerCase() : letter.toLowerCase();
  });
}

// Generate TypeScript interface name from entity name
function getInfoInterface(entityName) {
  // Check if we have a specific interface defined
  const specificInterfaces = {
    'BinarySensor': 'BinarySensorInfo',
    'Sensor': 'SensorInfo',
    'Switch': 'SwitchInfo',
    'Light': 'LightInfo',
  };
  
  return specificInterfaces[entityName] || 'EntityInfo';
}

// Generate state interface name
function getStateInterface(entityName) {
  const specificStates = {
    'BinarySensor': 'BinarySensorState',
    'Sensor': 'SensorState',
    'Switch': 'SwitchState',
    'TextSensor': 'TextSensorState',
  };
  
  return specificStates[entityName] || 'StateUpdate';
}

// Generate TypeScript type definitions
function generateTypeScript(entities) {
  const snakeCaseTypes = entities.map(toSnakeCase);
  
  let output = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by scripts/generate-entity-types.js
 * 
 * This file contains entity type definitions automatically extracted from proto files.
 * To regenerate, run: npm run generate:entity-types
 */

import type {
  EntityInfo,
  BinarySensorInfo,
  SensorInfo,
  SwitchInfo,
  LightInfo,
  StateUpdate,
  BinarySensorState,
  SensorState,
  SwitchState,
  TextSensorState,
} from './index';

/**
 * All possible entity types supported by ESPHome
 * Auto-generated from proto file
 */
export type EntityType =
${snakeCaseTypes.map(type => `  | '${type}'`).join('\n')};

/**
 * Map entity type string to entity info interface
 * Auto-generated from proto file
 */
export interface EntityTypeMap {
${entities.map(name => `  ${toSnakeCase(name)}: ${getInfoInterface(name)};`).join('\n')}
}

/**
 * Map entity type string to state interface
 * Auto-generated from proto file
 */
export interface EntityStateMap {
${entities.map(name => `  ${toSnakeCase(name)}: ${getStateInterface(name)};`).join('\n')}
}

/**
 * Get entity info type by entity type string
 */
export type EntityInfoByType<T extends EntityType> = EntityTypeMap[T];

/**
 * Get state type by entity type string
 */
export type EntityStateByType<T extends EntityType> = EntityStateMap[T];

/**
 * Helper to create discriminated union based on entity type
 */
export type EntityWithType<T extends EntityType> = EntityInfoByType<T> & {
  entityType: T;
};

/**
 * All possible entity types as discriminated union
 * Auto-generated from proto file
 */
export type AnyEntity =
${entities.map(name => `  | EntityWithType<'${toSnakeCase(name)}'>`).join('\n')};

/**
 * Array of all entity type strings
 * Useful for validation and iteration
 */
export const ALL_ENTITY_TYPES: readonly EntityType[] = [
${snakeCaseTypes.map(type => `  '${type}',`).join('\n')}
] as const;

/**
 * Check if a string is a valid entity type
 */
export function isValidEntityType(type: string): type is EntityType {
  return ALL_ENTITY_TYPES.includes(type as EntityType);
}
`;
  
  return output;
}

// Main execution
function main() {
  console.log('Reading proto file:', PROTO_FILE);
  const protoContent = fs.readFileSync(PROTO_FILE, 'utf-8');
  
  console.log('Parsing entity types...');
  const entities = parseProtoFile(protoContent);
  
  console.log(`Found ${entities.length} entity types:`);
  entities.forEach(entity => {
    console.log(`  - ${entity} (${toSnakeCase(entity)})`);
  });
  
  console.log('\nGenerating TypeScript definitions...');
  const tsContent = generateTypeScript(entities);
  
  console.log('Writing to:', OUTPUT_FILE);
  fs.writeFileSync(OUTPUT_FILE, tsContent, 'utf-8');
  
  console.log('\nâœ“ Entity types generated successfully!');
  console.log('\nNext steps:');
  console.log('  1. Update src/types/index.ts to export from generated-entity-types.ts');
  console.log('  2. Remove manual entity type definitions');
  console.log('  3. Run npm run build to verify');
}

// Run if executed directly
if (require.main === module) {
  try {
    main();
  } catch (error) {
    console.error('Error generating entity types:', error);
    process.exit(1);
  }
}

module.exports = { parseProtoFile, toSnakeCase, generateTypeScript };
